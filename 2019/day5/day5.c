#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>

bool is_valid_opcode(int o) {
    if (o == 1 || o == 2 || o == 3 || o == 4 || o == 99) {
        return true;
    }
    return false;
}
int get(int mem[], int addr) {
    return mem[addr];
}

void set(int mem[], int val, int addr) {
    mem[addr] = val;
}

void add(int mem[], int a, int b, int addr) {
  set(mem, a + b, addr);
}

void multiply(int mem[], int a, int b, int addr) {
    set(mem, a * b, addr);
}

void done() {
    printf("program terminated successfully\n");
    exit(EXIT_SUCCESS);
}

void echo(int mem[], int addr) {
    printf("value is %d\n", mem[addr]);
}

int main() {
    // puzzle input
    int mem[] = {3,225,1,225,6,6,1100,1,238,225,104,0,1101,90,60,224,1001,224,-150,224,4,224,1002,223,8,223,1001,224,7,224,1,224,223,223,1,57,83,224,1001,224,-99,224,4,224,1002,223,8,223,1001,224,5,224,1,223,224,223,1102,92,88,225,101,41,187,224,1001,224,-82,224,4,224,1002,223,8,223,101,7,224,224,1,224,223,223,1101,7,20,225,1101,82,64,225,1002,183,42,224,101,-1554,224,224,4,224,102,8,223,223,1001,224,1,224,1,224,223,223,1102,70,30,224,101,-2100,224,224,4,224,102,8,223,223,101,1,224,224,1,224,223,223,2,87,214,224,1001,224,-2460,224,4,224,1002,223,8,223,101,7,224,224,1,223,224,223,102,36,180,224,1001,224,-1368,224,4,224,1002,223,8,223,1001,224,5,224,1,223,224,223,1102,50,38,225,1102,37,14,225,1101,41,20,225,1001,217,7,224,101,-25,224,224,4,224,1002,223,8,223,101,2,224,224,1,224,223,223,1101,7,30,225,1102,18,16,225,4,223,99,0,0,0,677,0,0,0,0,0,0,0,0,0,0,0,1105,0,99999,1105,227,247,1105,1,99999,1005,227,99999,1005,0,256,1105,1,99999,1106,227,99999,1106,0,265,1105,1,99999,1006,0,99999,1006,227,274,1105,1,99999,1105,1,280,1105,1,99999,1,225,225,225,1101,294,0,0,105,1,0,1105,1,99999,1106,0,300,1105,1,99999,1,225,225,225,1101,314,0,0,106,0,0,1105,1,99999,7,226,226,224,102,2,223,223,1006,224,329,101,1,223,223,1107,677,226,224,102,2,223,223,1006,224,344,1001,223,1,223,8,677,226,224,1002,223,2,223,1005,224,359,101,1,223,223,107,677,677,224,1002,223,2,223,1006,224,374,101,1,223,223,7,677,226,224,1002,223,2,223,1006,224,389,101,1,223,223,108,677,226,224,1002,223,2,223,1005,224,404,101,1,223,223,1108,677,226,224,102,2,223,223,1005,224,419,101,1,223,223,8,226,677,224,102,2,223,223,1006,224,434,1001,223,1,223,1008,677,677,224,1002,223,2,223,1005,224,449,1001,223,1,223,1107,226,677,224,102,2,223,223,1006,224,464,101,1,223,223,107,226,677,224,1002,223,2,223,1006,224,479,1001,223,1,223,7,226,677,224,102,2,223,223,1005,224,494,1001,223,1,223,8,677,677,224,102,2,223,223,1006,224,509,1001,223,1,223,1108,677,677,224,102,2,223,223,1005,224,524,1001,223,1,223,1108,226,677,224,1002,223,2,223,1005,224,539,101,1,223,223,107,226,226,224,102,2,223,223,1006,224,554,1001,223,1,223,1007,226,226,224,102,2,223,223,1005,224,569,1001,223,1,223,1008,226,226,224,102,2,223,223,1005,224,584,101,1,223,223,1007,677,677,224,1002,223,2,223,1005,224,599,1001,223,1,223,108,677,677,224,1002,223,2,223,1006,224,614,1001,223,1,223,1007,226,677,224,1002,223,2,223,1006,224,629,101,1,223,223,1008,677,226,224,102,2,223,223,1005,224,644,101,1,223,223,1107,226,226,224,1002,223,2,223,1005,224,659,1001,223,1,223,108,226,226,224,1002,223,2,223,1005,224,674,101,1,223,223,4,223,99,226};
    int mem_size = sizeof(mem) / sizeof(mem[0]);
    int step = 4; // default length the fp should move

    for (int fp = 0; fp < mem_size; fp += step) { // fp == function pointer
        int op = mem[fp];
        if (op == 99) done(); // abort execution

        int param1_mode = 0, param2_mode = 0, param3_mode = 0;

        if (op > 99) {
            op     = (mem[fp] % 100) / 1; // 1234 -> 34
            param1_mode = (mem[fp] % 1000) / 100; // 1234 -> 2
            param2_mode = (mem[fp] % 10000) / 1000; // 1234 -> 1
            param3_mode = (mem[fp] % 100000) / 10000; // 1234 -> 0 (or e.g. 31234 -> 3)
        }

        if (! is_valid_opcode(op)) {
            printf("Error: %d is not a valid opcode\n", op);
            exit(EXIT_FAILURE);
        }
        
        int addr_a = mem[fp + 1];
        int addr_b = mem[fp + 2];
        int addr_c = mem[fp + 3];

        int r = -1, l = -1, addr = -1;

        if (param1_mode == 0) { // position mode
          r = get(mem, addr_a);
        } else if (param1_mode == 1) { // immediate mode
            r = addr_a;
        }
        
        if (param2_mode == 0) {
          l = get(mem, addr_b);
        } else if (param2_mode == 1) {
          l = addr_b;
        }

        if (param3_mode == 0) {
          addr = addr_c;
        } else if (param3_mode == 1) {
            printf("param 3 should never be in immediate mode\n");
            exit(EXIT_FAILURE);
        }

        if (op == 1) {
          add(mem, r, l, addr);
            step = 4;
        } else if (op == 2) {
          multiply(mem, r, l, addr);
            step = 4;
        } else if (op == 3) {
          int input;
          printf("Enter an integer: ");
          scanf("%d", &input);
          set(mem, input, get(mem, fp + 1));
          step = 2;
        } else if (op == 4) {
          if (param1_mode == 0) {
            echo(mem, get(mem, fp + 1));
          } else {
            echo(mem, fp + 1);
          }
          step = 2;
        }
    }
}
